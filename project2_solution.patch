diff --git a/Makefile b/Makefile
index 26d5b29..4bb5efd 100644
--- a/Makefile
+++ b/Makefile
@@ -53,7 +53,8 @@ OBJDUMP := objdump
 ################################################################################
 
 # If the makefile can't find QEMU, specify its path here
-#QEMU :=
+QEMU := qemu-system-x86_64
+
 
 # Try to infer the correct QEMU if not specified
 ifndef QEMU
diff --git a/include/syscall.h b/include/syscall.h
index c55cec2..472c26d 100644
--- a/include/syscall.h
+++ b/include/syscall.h
@@ -23,5 +23,7 @@
 #define SYS_sbrk   19
 #define SYS_sleep  20
 #define SYS_uptime 21
+#define SYS_shmem_access 22
+#define SYS_shmem_count 23
 
 #endif // _SYSCALL_H_
diff --git a/kernel/bootasm.S b/kernel/bootasm.S
index e06ab6f..8e9a9ae 100644
--- a/kernel/bootasm.S
+++ b/kernel/bootasm.S
@@ -5,6 +5,15 @@
 # memory at physical address 0x7c00 and starts executing in real mode
 # with %cs=0 %ip=7c00.
 
+
+# the first sector of the hard disk is the Boot Sector
+# load it into the physical address 0x7c00, that's what BIOS
+# do, now CPU is working in real mode, and ready to switch to 
+# 32 bit protected mode.
+
+
+
+
 #define SEG_KCODE 1  // kernel code
 #define SEG_KDATA 2  // kernel data+stack
 
@@ -15,6 +24,7 @@
 start:
   cli                         # BIOS enabled interrupts; disable
 
+	# 16 bit segment registers in real mode
   # Set up the important data segment registers (DS, ES, SS).
   xorw    %ax,%ax             # Segment number zero
   movw    %ax,%ds             # -> Data Segment
@@ -42,6 +52,8 @@ seta20.2:
   # Switch from real to protected mode.  Use a bootstrap GDT that makes
   # virtual addresses map dierctly to  physical addresses so that the
   # effective memory map doesn't change during the transition.
+	
+	# cr0 is a 32 bit control reg, which 0 bit is the PE, the following part can transit to protected mode
   lgdt    gdtdesc
   movl    %cr0, %eax
   orl     $CR0_PE, %eax
diff --git a/kernel/defs.h b/kernel/defs.h
index c12f8ff..a515f4a 100644
--- a/kernel/defs.h
+++ b/kernel/defs.h
@@ -169,6 +169,13 @@ void            switchuvm(struct proc*);
 void            switchkvm(void);
 int             copyout(pde_t*, uint, void*, uint);
 
+void            shinit(void);
+void            shmem_init(void);
+void*           shmem_access(int page_number);
+int             shmem_count(int page_number);
+void            shmem_free(struct proc *p);
+void            shmem_fork(struct proc *p);
+
 // number of elements in fixed-size array
 #define NELEM(x) (sizeof(x)/sizeof((x)[0]))
 
diff --git a/kernel/exec.c b/kernel/exec.c
index 05f80f8..f5cf9b6 100644
--- a/kernel/exec.c
+++ b/kernel/exec.c
@@ -32,7 +32,8 @@ exec(char *path, char **argv)
     goto bad;
 
   // Load program into memory.
-  sz = 0;
+  //sz = 0;
+	sz = PGSIZE;
   for(i=0, off=elf.phoff; i<elf.phnum; i++, off+=sizeof(ph)){
     if(readi(ip, (char*)&ph, off, sizeof(ph)) != sizeof(ph))
       goto bad;
diff --git a/kernel/main.c b/kernel/main.c
index e9dc44c..484bcbb 100644
--- a/kernel/main.c
+++ b/kernel/main.c
@@ -57,7 +57,9 @@ mainc(void)
   if(!ismp)
     timerinit();   // uniprocessor timer
   bootothers();    // start other processors
-
+	
+	//shinit();		//share memory lock
+	//shmem_init();
   // Finish setting up this processor in
   cinit();
   sti();           // enable inturrupts
diff --git a/kernel/mmu.h b/kernel/mmu.h
index 3b6286f..ca3eb6f 100644
--- a/kernel/mmu.h
+++ b/kernel/mmu.h
@@ -3,6 +3,8 @@
 // This file contains definitions for the
 // x86 memory management unit (MMU).
 
+#define SHAREDMEMMAX 4
+
 // Eflags register
 #define FL_CF           0x00000001      // Carry Flag
 #define FL_PF           0x00000004      // Parity Flag
diff --git a/kernel/proc.c b/kernel/proc.c
index 8e20984..832c9b2 100644
--- a/kernel/proc.c
+++ b/kernel/proc.c
@@ -11,6 +11,8 @@ struct {
   struct proc proc[NPROC];
 } ptable;
 
+
+
 static struct proc *initproc;
 
 int nextpid = 1;
@@ -48,11 +50,12 @@ found:
   release(&ptable.lock);
 
   // Allocate kernel stack if possible.
-  if((p->kstack = kalloc()) == 0){
+	// in kalloc.c, allocate a 4096 page 
+  if((p->kstack = kalloc()) == 0){   
     p->state = UNUSED;
     return 0;
   }
-  sp = p->kstack + KSTACKSIZE;
+  sp = p->kstack + KSTACKSIZE;   //KSTACKSIZE = 4096
   
   // Leave room for trap frame.
   sp -= sizeof *p->tf;
@@ -67,7 +70,11 @@ found:
   p->context = (struct context*)sp;
   memset(p->context, 0, sizeof *p->context);
   p->context->eip = (uint)forkret;
-
+	int i;
+	for(i = 0;i < SHAREDMEMMAX; i++)
+	{
+			p->shmem[i] = 0;
+	}
   return p;
 }
 
@@ -156,6 +163,11 @@ fork(void)
   pid = np->pid;
   np->state = RUNNABLE;
   safestrcpy(np->name, proc->name, sizeof(proc->name));
+	for(i = 0;i < SHAREDMEMMAX; i++)
+	{
+			np->shmem[i] = proc->shmem[i];
+	}
+	shmem_fork(np);
   return pid;
 }
 
@@ -196,6 +208,7 @@ exit(void)
     }
   }
 
+	shmem_free(proc);
   // Jump into the scheduler, never to return.
   proc->state = ZOMBIE;
   sched();
diff --git a/kernel/proc.h b/kernel/proc.h
index 7d64023..f3929f3 100644
--- a/kernel/proc.h
+++ b/kernel/proc.h
@@ -61,6 +61,7 @@ enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
 
 // Per-process state
 struct proc {
+	int shmem[SHAREDMEMMAX];
   uint sz;                     // Size of process memory (bytes)
   pde_t* pgdir;                // Page table
   char *kstack;                // Bottom of kernel stack for this process
diff --git a/kernel/syscall.c b/kernel/syscall.c
index 28c8308..1ea1c20 100644
--- a/kernel/syscall.c
+++ b/kernel/syscall.c
@@ -17,6 +17,8 @@
 int
 fetchint(struct proc *p, uint addr, int *ip)
 {
+	if(p->pid != 1 && addr < PGSIZE)
+			return -1;
   if(addr >= p->sz || addr+4 > p->sz)
     return -1;
   *ip = *(int*)(addr);
@@ -31,6 +33,9 @@ fetchstr(struct proc *p, uint addr, char **pp)
 {
   char *s, *ep;
 
+	if(p->pid != 1 && addr < PGSIZE)
+			return -1;
+
   if(addr >= p->sz)
     return -1;
   *pp = (char*)addr;
@@ -59,6 +64,7 @@ argptr(int n, char **pp, int size)
   if(argint(n, &i) < 0)
     return -1;
   if((uint)i >= proc->sz || (uint)i+size > proc->sz)
+	//if((uint)i >= proc->sz || (uint)i+size > proc->sz || (uint)i < PGSIZE)	
     return -1;
   *pp = (char*)i;
   return 0;
@@ -74,6 +80,8 @@ argstr(int n, char **pp)
   int addr;
   if(argint(n, &addr) < 0)
     return -1;
+	//if((uint)addr >= proc->sz || (uint)addr < PGSIZE)
+	//	return -1;
   return fetchstr(proc, addr, pp);
 }
 
@@ -103,6 +111,8 @@ static int (*syscalls[])(void) = {
 [SYS_wait]    sys_wait,
 [SYS_write]   sys_write,
 [SYS_uptime]  sys_uptime,
+[SYS_shmem_access] sys_shmem_access,
+[SYS_shmem_count] sys_shmem_count
 };
 
 // Called on a syscall trap. Checks that the syscall number (passed via eax)
diff --git a/kernel/sysfunc.h b/kernel/sysfunc.h
index ee9dafd..2ec3fdf 100644
--- a/kernel/sysfunc.h
+++ b/kernel/sysfunc.h
@@ -23,5 +23,7 @@ int sys_unlink(void);
 int sys_wait(void);
 int sys_write(void);
 int sys_uptime(void);
+int sys_shmem_access(void);
+int sys_shmem_count(void);
 
 #endif // _SYSFUNC_H_
diff --git a/kernel/sysproc.c b/kernel/sysproc.c
index 82b54f9..efb448c 100644
--- a/kernel/sysproc.c
+++ b/kernel/sysproc.c
@@ -88,3 +88,28 @@ sys_uptime(void)
   release(&tickslock);
   return xticks;
 }
+
+
+//share memory system call
+int
+sys_shmem_access(void)
+{
+	int n;
+	if(argint(0, &n) < 0)
+		return -1;
+	return (int)shmem_access(n);
+			
+}
+
+
+
+
+
+int
+sys_shmem_count(void)
+{
+	int n;
+	if (argint(0, &n) < 0)
+		return -1;
+	return shmem_count(n);
+}
diff --git a/kernel/vectors.pl b/kernel/vectors.pl
index 57b49dd..3faa5ba 100644
--- a/kernel/vectors.pl
+++ b/kernel/vectors.pl
@@ -1,5 +1,14 @@
 #!/usr/bin/perl -w
 
+
+#The x86 allows for 256
+#different interrupts. Interrupts 0-31 are 
+#defined for software exceptions, like divide errors
+#or attempts to access invalid memory addresses. 
+#Xv6 maps the 32 hardware interrupts
+#to the range 32-63 and uses interrupt 64 
+#as the system call interrupt.
+
 # Generate vectors.S, the trap/interrupt entry points.
 # There has to be one entry point per interrupt number
 # since otherwise there's no way for trap() to discover
diff --git a/kernel/vm.c b/kernel/vm.c
index 54d4bf4..5e5dafb 100644
--- a/kernel/vm.c
+++ b/kernel/vm.c
@@ -5,6 +5,14 @@
 #include "mmu.h"
 #include "proc.h"
 #include "elf.h"
+#include "spinlock.h"
+
+
+struct{
+		struct spinlock lock;
+		int count[SHAREDMEMMAX];  //how many procs sharing 
+		void* addr[SHAREDMEMMAX]; //address of each share memories
+}shmems;
 
 extern char data[];  // defined in data.S
 
@@ -139,9 +147,10 @@ setupkvm(void)
 
   if((pgdir = (pde_t*)kalloc()) == 0)
     return 0;
-  memset(pgdir, 0, PGSIZE);
+  memset(pgdir, 0, PGSIZE);   //set all the page to 0
   k = kmap;
-  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)
+  for(k = kmap; k < &kmap[NELEM(kmap)]; k++)    
+			//#define NELEM(x) (sizeof(x)/sizeof((x)[0]))
     if(mappages(pgdir, k->p, k->e - k->p, (uint)k->p, k->perm) < 0)
       return 0;
 
@@ -231,7 +240,8 @@ allocuvm(pde_t *pgdir, uint oldsz, uint newsz)
   char *mem;
   uint a;
 
-  if(newsz > USERTOP)
+  //if(newsz  > USERTOP)
+	if(newsz > USERTOP - PGSIZE*SHAREDMEMMAX)
     return 0;
   if(newsz < oldsz)
     return oldsz;
@@ -286,7 +296,7 @@ freevm(pde_t *pgdir)
 
   if(pgdir == 0)
     panic("freevm: no pgdir");
-  deallocuvm(pgdir, USERTOP, 0);
+  deallocuvm(pgdir, USERTOP - SHAREDMEMMAX*PGSIZE, 0);
   for(i = 0; i < NPDENTRIES; i++){
     if(pgdir[i] & PTE_P)
       kfree((char*)PTE_ADDR(pgdir[i]));
@@ -306,7 +316,7 @@ copyuvm(pde_t *pgdir, uint sz)
 
   if((d = setupkvm()) == 0)
     return 0;
-  for(i = 0; i < sz; i += PGSIZE){
+  for(i = PGSIZE; i < sz; i += PGSIZE){
     if((pte = walkpgdir(pgdir, (void*)i, 0)) == 0)
       panic("copyuvm: pte should exist");
     if(!(*pte & PTE_P))
@@ -364,3 +374,108 @@ copyout(pde_t *pgdir, uint va, void *p, uint len)
   }
   return 0;
 }
+
+
+// Initialize shared memory's locker
+void
+shinit(void)
+{
+		initlock(&shmems.lock,"shmems");
+}
+
+
+
+void 
+shmem_init(void)
+{
+		acquire(&shmems.lock);
+		int i;
+		for(i = 0;i < SHAREDMEMMAX; i++)
+		{
+				shmems.count[i] = 0;
+				shmems.addr[i] = NULL;
+		}
+		release(&shmems.lock);
+}
+
+
+void* 
+shmem_access(int page_number)
+{
+		if(page_number < 0 || page_number > SHAREDMEMMAX) return NULL;
+		void* va = (void*)(USERTOP - PGSIZE * (page_number + 1));
+		acquire(&shmems.lock);
+		if(proc->shmem[page_number])
+		{
+				if(mappages(proc->pgdir,va,PGSIZE,PADDR(shmems.addr[page_number]),PTE_W|PTE_U)<0)
+				{
+					release(&shmems.lock);
+					return NULL;
+				}
+				
+				
+				release(&shmems.lock);
+				return va;
+				
+		}
+		if((shmems.addr[page_number] = kalloc()) == 0)
+		{
+				proc->shmem[page_number] = 0;
+				release(&shmems.lock);
+				return NULL;
+		}
+
+		mappages(proc->pgdir,va,PGSIZE,PADDR(shmems.addr[page_number]),PTE_W|PTE_U);
+		shmems.count[page_number]++;
+		proc->shmem[page_number] = 1;
+		release(&shmems.lock);
+		return va;
+		
+}
+
+
+
+int
+shmem_count(int page_number)
+{
+		if(page_number < 0 || page_number >= SHAREDMEMMAX)
+				return -1;
+		return shmems.count[page_number];
+}
+
+
+
+void
+shmem_free(struct proc* p)
+{
+		acquire(&shmems.lock);
+		int i;
+		for(i = 0;i < SHAREDMEMMAX; i++)
+		{
+				if(p->shmem[i])
+				{
+						shmems.count[i]--;
+						if(shmems.count[i]==0&&shmems.addr[i])
+						{
+								kfree((char*)shmems.addr[i]);
+								shmems.addr[i] = NULL;
+						}
+				}
+				p->shmem[i] = 0;
+		}
+		release(&shmems.lock);
+}
+
+
+void
+shmem_fork(struct proc* p)
+{
+		acquire(&shmems.lock);
+		int i;
+		for(i = 0;i < SHAREDMEMMAX; i++)
+		{
+				if(p->shmem[i])
+						shmems.count[i]++;
+		}
+		release(&shmems.lock);
+}
diff --git a/team.txt b/team.txt
new file mode 100644
index 0000000..0225659
--- /dev/null
+++ b/team.txt
@@ -0,0 +1,2 @@
+yld7548
+dab7966
diff --git a/user/makefile.mk b/user/makefile.mk
index 1441eb8..31eb241 100644
--- a/user/makefile.mk
+++ b/user/makefile.mk
@@ -16,7 +16,8 @@ USER_PROGS := \
 	tester\
 	usertests\
 	wc\
-	zombie
+	zombie\
+	sharedmem_simpletests
 
 USER_PROGS := $(addprefix user/, $(USER_PROGS))
 
@@ -73,7 +74,9 @@ USER_LDFLAGS += --omagic
 USER_LDFLAGS += --entry=main
 
 # location in memory where the program will be loaded
-USER_LDFLAGS += --section-start=.text=0x0
+//USER_LDFLAGS += --section-start=.text=0x0
+USER_LDFLAGS += --section-start=.text=0x1000
+
 
 user/bin:
 	mkdir -p user/bin
diff --git a/user/sharedmem_simpletests.c b/user/sharedmem_simpletests.c
new file mode 100644
index 0000000..539b152
--- /dev/null
+++ b/user/sharedmem_simpletests.c
@@ -0,0 +1,248 @@
+#include "types.h"
+#include "stat.h"
+#include "user.h"
+
+#define USERTOP 0xA0000
+#define PGSIZE 4096
+
+void
+testPassed(void)
+{
+  printf(1, "....Passed\n");
+}
+
+void
+testFailed(void)
+{
+  printf(1, "....FAILED\n");
+}
+
+void expectedVersusActualNumeric(char* name, int expected, int actual)
+{
+  printf(1, "      %s expected: %d, Actual: %d\n", name, expected, actual);
+}
+
+void
+whenRequestingSharedMemory_ValidAddressIsReturned(void)
+{
+  printf(1, "Test: whenRequestingSharedMemory_ValidAddressIsReturned...");
+  char* sharedPage = shmem_access(0);
+  char* highestPage =       (char*)(USERTOP - PGSIZE);
+  char* secondHighestPage = (char*)(USERTOP - 2*PGSIZE);
+  char* thirdHighestPage =  (char*)(USERTOP - 3*PGSIZE);
+  char* fourthHighestPage = (char*)(USERTOP - 4*PGSIZE);
+  
+  if(sharedPage == highestPage ||
+     sharedPage == secondHighestPage ||
+     sharedPage == thirdHighestPage ||
+     sharedPage == fourthHighestPage) {
+    testPassed();
+  } else {
+    testFailed(); 
+  }
+}
+
+void
+afterRequestingSharedMemory_countReturns1()
+{
+  printf(1, "Test: afterRequestingSharedMemory_countReturns1...");
+  char* sharedPage = shmem_access(0);
+  int count = shmem_count(0);
+
+  if(count == 1) {
+    testPassed();
+  } else {
+    testFailed();
+    expectedVersusActualNumeric("'count'", 1, count);
+  }
+
+  // silence the error about unused variable
+  sharedPage = sharedPage + 0;
+}
+
+void
+whenSharingAPage_ParentSeesChangesMadeByChild()
+{
+  printf(1, "Test: whenSharingAPage_ParentSeesChangesMadeByChild...");
+  char* sharedPage = shmem_access(0);
+  sharedPage[0] = 42;
+
+  int pid = fork();
+  if(pid == 0){
+    // in child
+    char* childsSharedPage = shmem_access(0);
+    childsSharedPage[0] = childsSharedPage[0] + 1;
+    exit();
+  } else {
+    // in parent
+    wait(); // wait for child to terminate
+    if(sharedPage[0] == 43){
+      testPassed();
+    } else {
+      testFailed();
+      expectedVersusActualNumeric("'sharedPage[0]'", 43, sharedPage[0]);
+    }
+  }
+}
+
+void
+whenProcessExits_SharedPageIsFreed()
+{
+  printf(1, "Test: whenProcessExits_SharedPageIsFreed...");
+  int pid = fork();
+
+  if(pid == 0){
+    // in child
+    char* sharedPage = shmem_access(0);
+    sharedPage[0] = 42;
+    exit();
+  } else {
+    // in parent
+    wait();
+    char* parentsSharedPage = shmem_access(0);
+    if(parentsSharedPage[0] != 42){
+      testPassed();
+    } else {
+      // should be garbage value after being freed, but it's still 42
+      testFailed();
+      expectedVersusActualNumeric("'parentsSharedPage[0]'", 1, parentsSharedPage[0]);
+    }
+  }
+}
+
+void
+whenSharingAPageBetween2Processes_countReturns2()
+{
+  printf(1, "Test: whenSharingAPageBetween2Processes_countReturns2...");
+
+  char* sharedPage = shmem_access(0);
+  sharedPage = sharedPage + 0;  // silence unused variable error
+
+  int pid = fork();
+
+  if(pid == 0){
+    // in child
+    char* childsSharedPage = shmem_access(0);
+    childsSharedPage = childsSharedPage + 0;  // silence unused variable error
+
+    int count = shmem_count(0);
+    if(count != 2){
+      testFailed();
+      expectedVersusActualNumeric("'count'", 2, count);
+    }
+
+    exit();
+  } else{
+    // in parent
+    wait(); // wait for child to exit
+    int parentsCount = shmem_count(0);
+    if(parentsCount != 1){
+      testFailed();
+      expectedVersusActualNumeric("'parentsCount'", 1, parentsCount);
+    }
+  }
+
+  testPassed();
+}
+
+void
+whenProcessExists_countReturns0()
+{
+  printf(1, "Test: whenProcessExists_countReturns0...");
+
+  int pid = fork();
+
+  if(pid == 0){
+    // in child
+    char* sharedPage = shmem_access(0);
+    sharedPage = sharedPage + 0;  // silence unused variable error
+    exit();
+  } else {
+    // in parent
+    wait();
+    int count = shmem_count(0);
+
+    if(count != 0){
+      testFailed();
+      expectedVersusActualNumeric("'count'", 0, count);
+    } else {
+      testPassed();
+    }
+
+  }
+}
+
+void
+beforeRequestingSharedMemory_countReturns0()
+{
+  printf(1, "Test: beforeRequestingSharedMemory_countReturns0...");
+
+  int count = shmem_count(0);
+
+  if(count != 0){
+    testFailed();
+    expectedVersusActualNumeric("'count'", 0, count);
+  } else {
+    testPassed();
+  }
+}
+
+int
+main(void)
+{
+  int pid;
+
+  // we fork then run each test in a child process to keep the main process
+  // free of any shared memory
+  pid = fork();
+  if(pid == 0){
+    whenRequestingSharedMemory_ValidAddressIsReturned();
+    exit();
+  }
+  wait();
+  
+  pid = fork();
+  if(pid == 0){
+    afterRequestingSharedMemory_countReturns1();
+    exit();
+  }
+  wait();
+
+  pid = fork();
+  if(pid == 0){
+    whenSharingAPage_ParentSeesChangesMadeByChild();
+    exit();
+  }
+  wait();
+
+  pid = fork();
+  if(pid == 0){
+    whenSharingAPageBetween2Processes_countReturns2();
+    exit();
+  }
+  wait();
+
+  pid = fork();
+  if(pid == 0){
+    whenProcessExits_SharedPageIsFreed();
+    exit();
+  }
+  wait();
+
+  pid = fork();
+  if(pid == 0){
+    whenProcessExists_countReturns0();
+    exit();
+  }
+  wait();
+
+  pid = fork();
+  if(pid == 0){
+    beforeRequestingSharedMemory_countReturns0();
+    exit();
+  }
+  wait();
+
+
+  exit();
+}
diff --git a/user/user.h b/user/user.h
index 2b68ee0..1bebb48 100644
--- a/user/user.h
+++ b/user/user.h
@@ -25,6 +25,8 @@ int getpid(void);
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+void* shmem_access(int page_number);
+int shmem_count(int page_number);
 
 // user library functions (ulib.c)
 int stat(char*, struct stat*);
diff --git a/user/usys.S b/user/usys.S
index 8bfd8a1..5bfed04 100644
--- a/user/usys.S
+++ b/user/usys.S
@@ -29,3 +29,5 @@ SYSCALL(getpid)
 SYSCALL(sbrk)
 SYSCALL(sleep)
 SYSCALL(uptime)
+SYSCALL(shmem_access)
+SYSCALL(shmem_count)
